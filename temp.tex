\documentclass[a4paper]{article}
\usepackage{xeCJK}
\usepackage{geometry}
\usepackage{listings}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage[CJKbookmarks = true]{hyperref}
\hypersetup{colorlinks = true, linkcolor = black}
\geometry{left = 2.5cm, right = 2.5cm, top = 2.54cm, bottom = 2.54cm}
\title{模板}
\author{Wajov}
\begin{document}
\maketitle
\renewcommand{\contentsname}{目录}
\pagenumbering{Roman}
\tableofcontents
\newpage
\pagenumbering{arabic}
\newfontfamily\consolas{Consolas}
\lstset{language = C++, basicstyle = \footnotesize\consolas, numbers = left, numberstyle = \footnotesize\consolas, frame = single, keywordstyle = \color{blue}, stringstyle = \color{red}, commentstyle = \color{gray}}
\section{字符串算法}
\subsection{最小表示}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, x, y, t, ans;
char s[N + 10];
int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    x = 1;
    y = 2;
    for (int i = 0; x <= n && y <= n && i <= n; ) {
        t = s[(x + i - 1) % n + 1] - s[(y + i - 1) % n + 1];
        if (!t)
            i++;
        else {
            t > 0 ? x += i + 1 : y += i + 1;
            if (x == y)
                y++;
            i = 0;
        }
    }
    ans = min(x, y);
    for (int i = ans; i <= n; i++)
        putchar(s[i]);
    for (int i = 1; i < ans; i++)
        putchar(s[i]);
    puts("");
    return 0;
}
\end{lstlisting}
\subsection{Manacher}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, ans, p[N << 1];
char c, s[N << 1];
int main() {
    s[0] = '$';
    while ((c = getchar()) != '\n') {
        s[++n] = '#';
        s[++n] = c;
    }
    s[++n] = '#';
    for (int i = 1, j = 0; i <= n; i++) {
        p[i] = i < j + p[j] ? min(p[(j << 1) - i], j + p[j] - i) : 1;
        while (s[i + p[i]] == s[i - p[i]])
            p[i]++;
        if (i + p[i] > j + p[j])
            j = i;
        ans = max(ans, p[i] - 1);
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Knuth-Morris-Pratt}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, m, num, p[N], ans[N];
char a[N + 10], b[N + 10];
int main() {
    scanf("%s%s", a + 1, b + 1);
    n = strlen(a + 1);
    m = strlen(b + 1);
    for (int i = 2, j = 0; i <= m; i++) {
        for (; j > 0 && b[j + 1] != b[i]; j = p[j]);
        if (b[j + 1] == b[i])
            j++;
        p[i] = j;
    }
    for (int i = 1, j = 0; i <= n; i++) {
        for (; j > 0 && b[j + 1] != a[i]; j = p[j]);
        if (b[j + 1] == a[i])
            j++;
        if (j == m) {
            ans[++num] = i - j + 1;
            j = p[j];
        }
    }
    for (int i = 1; i < num; i++)
        printf("%d ", ans[i]);
    printf("%d\n", ans[num]);
    return 0;
}
\end{lstlisting}
\subsection{扩展Knuth-Morris-Pratt}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, m, p[N], ex[N];
char a[N + 10], b[N + 10];
int main() {
    scanf("%s%s", a + 1, b + 1);
    n = strlen(a + 1);
    m = strlen(b + 1);
    for (int i = 2, j = 0; i <= m; i++) {
        p[i] = i < j + p[j] ? min(p[i - j + 1], j + p[j] - i) : 0;
        for (; i + p[i] <= m && b[i + p[i]] == b[p[i] + 1]; p[i]++);
        if (i + p[i] > j + p[j])
            j = i;
    }
    for (int i = 1, j = 0; i <= n; i++) {
        ex[i] = i <= j + ex[j] ? min(p[i - j + 1], j + ex[j] - i) : 0;
        for (; i + ex[i] <= n && ex[i] < m && a[i + ex[i]] == b[ex[i] + 1]; ex[i]++);
        if (i + ex[i] > j + ex[j])
            j = i;
    }
    for (int i = 1; i < n; i++)
        printf("%d ", ex[i]);
    printf("%d\n", ex[n]);
    return 0;
}
\end{lstlisting}
\subsection{Aho-Corasick}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, t, now, pos, ans, son[N][26], num[N], p[N];
char a[N + 10], b[N + 10];
queue<int> q;
void Insert(char s[]) {
    int p = 1, t;
    for (int i = 0; s[i]; i++) {
        t = s[i] - 97;
        if (!son[p][t])
            son[p][t] = ++pos;
        p = son[p][t];
    }
    num[p]++;
}
int main() {
    pos = 1;
    scanf("%s%d", a, &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", b);
        Insert(b);
    }
    for (int i = 0; i < 26; i++)
        son[0][i] = 1;
    q.push(1);
    while (!q.empty()) {
        now = q.front();
        q.pop();
        for (int i = 0; i < 26; i++)
            if (son[now][i]) {
                p[son[now][i]] = son[p[now]][i];
                q.push(son[now][i]);
            } else
                son[now][i] = son[p[now]][i];
    }
    t = 1;
    for (int i = 0; a[i]; i++) {
        t = son[t][a[i] - 97];
        for (int j = t; j > 1 && num[j] > -1; j = p[j]) {
            ans += num[j];
            num[j] = -1;
        }
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\section{图算法}
\subsection{拓扑排序}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001, M = 1000001;
int n, m, u, v, tot, num, Head[N], Next[M], Link[M], ans[N];
bool flag[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
void DFS(int x) {
    flag[x] = true;
    for (int i = Head[x], j; i; i = Next[i])
        if (!flag[j = Link[i]])
            DFS(j);
    ans[++num] = x;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
    }
    for (int i = 1; i <= n; i++)
        if (!flag[i])
            DFS(i);
    for (int i = n; i > 1; i--)
        printf("%d ", ans[i]);
    printf("%d\n", ans[1]);
    return 0;
}
\end{lstlisting}
\subsection{Floyd-Warshall}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 101;
int n, m, u, v, c, d[N][N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INT_MAX >> 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &c);
        d[u][v] = d[v][u] = min(d[u][v], c);
    }
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < n; j++)
            printf("%d ", d[i][j] == INT_MAX >> 1 ? -1 : d[i][j]);
        printf("%d\n", d[i][n] == INT_MAX >> 1 ? -1 : d[i][n]);
    }
    return 0;
}
\end{lstlisting}
\subsection{Floyd-Warshall（最小环）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 101;
int n, m, u, v, c, t, num, Min, a[N][N], d[N][N], p[N][N], ans[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            a[i][j] = i == j ? 0 : INT_MAX / 3;
            p[i][j] = i;
        }
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &c);
        a[u][v] = a[v][u] = min(a[u][v], c);
    }
    memcpy(d, a, sizeof(d));
    Min = INT_MAX / 3;
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i < k; i++)
            for (int j = 1; j < i; j++)
                if (d[i][j] + a[i][k] + a[k][j] < Min) {
                    Min = d[i][j] + a[i][k] + a[k][j];
                    for (num = 0, t = j; t != i; t = p[i][t])
                        ans[++num] = t;
                    ans[++num] = i;
                    ans[++num] = k;
                }
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (d[i][k] + d[k][j] < d[i][j]) {
                    d[i][j] = d[i][k] + d[k][j];
                    p[i][j] = p[k][j];
                }
    }
    printf("%d\n", Min);
    for (int i = 1; i < num; i++)
        printf("%d ", ans[i]);
    printf("%d\n", ans[num]);
    return 0;
}
\end{lstlisting}
\subsection{Bellman-Ford+队列}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001, M = 100001;
int n, m, s, u, v, c, now, tot, Head[N], Next[M << 1], Link[M << 1], Cost[M << 1], d[N];
bool flag[N];
queue<int> q;
inline void AddEdge(int u, int v, int c) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Cost[tot] = c;
    Head[u] = tot;
}
int main() {
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &c);
        AddEdge(u, v, c);
        AddEdge(v, u, c);
    }
    for (int i = 1; i <= n; i++)
        d[i] = INT_MAX;
    d[s] = 0;
    q.push(s);
    flag[s] = true;
    while (!q.empty()) {
        now = q.front();
        q.pop();
        flag[now] = false;
        for (int i = Head[now], j; i; i = Next[i])
            if (d[now] + Cost[i] < d[j = Link[i]]) {
                d[j] = d[now] + Cost[i];
                if (!flag[j]) {
                    q.push(j);
                    flag[j] = true;
                }
            }
    }
    for (int i = 1; i < n; i++)
        printf("%d ", d[i]);
    printf("%d\n", d[n]);
    return 0;
}
\end{lstlisting}
\subsection{Dijkstra+堆}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001, M = 100001;
int n, m, s, u, v, c, now, tot, d[N], Head[N], Next[M << 1], Link[M << 1], Cost[M << 1];
bool flag[N];
priority_queue<pair<int, int> > q;
inline void AddEdge(int u, int v, int c) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Cost[tot] = c;
    Head[u] = tot;
}
int main() {
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &c);
        AddEdge(u, v, c);
        AddEdge(v, u, c);
    }
    for (int i = 1; i <= n; i++)
        d[i] = INT_MAX;
    q.push(make_pair(d[s] = 0, s));
    while (!q.empty()) {
        now = q.top().second;
        q.pop();
        if (flag[now])
            continue;
        flag[now] = true;
        for (int i = Head[now], j; i; i = Next[i])
            if (d[now] + Cost[i] < d[j = Link[i]]) {
                d[j] = d[now] + Cost[i];
                q.push(make_pair(-d[j], j));
            }
    }
    for (int i = 1; i < n; i++)
        printf("%d ", d[i] == INT_MAX ? -1 : d[i]);
    printf("%d\n", d[n] == INT_MAX ? -1 : d[n]);
    return 0;
}
\end{lstlisting}
\subsection{Prim+堆}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001, M = 100001;
int n, m, s, u, v, c, now, ans, tot, Head[N], Next[M << 1], Link[M << 1], Cost[M << 1], d[N];
bool flag[N];
priority_queue<pair<int, int> > q;
inline void AddEdge(int u, int v, int c) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Cost[tot] = c;
    Head[u] = tot;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &c);
        AddEdge(u, v, c);
        AddEdge(v, u, c);
    }
    for (int i = 1; i <= n; i++)
        d[i] = INT_MAX;
    q.push(make_pair(d[1] = 0, 1));
    while (!q.empty()) {
        now = q.top().second;
        q.pop();
        if (flag[now])
            continue;
        ans += d[now];
        flag[now] = true;
        for (int i = Head[now], j; i; i = Next[i])
            if (Cost[i] < d[j = Link[i]]) {
                d[j] = Cost[i];
                q.push(make_pair(-d[j], j));
            }
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Tarjan（强连通分量）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001, M = 1000001;
int n, m, u, v, tot, num, idx, Head[N], Next[M], Link[M], dfn[N], low[N];
bool flag[N];
stack<int> s;
vector<int> sub[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
void DFS(int x) {
    s.push(x);
    flag[x] = true;
    low[x] = dfn[x] = ++idx;
    for (int i = Head[x], j; i; i = Next[i])
        if (!dfn[j = Link[i]]) {
            DFS(j);
            low[x] = min(low[x], low[j]);
        } else if (flag[j])
            low[x] = min(low[x], dfn[j]);
    if (low[x] == dfn[x]) {
        int t;
        num++;
        do {
            t = s.top();
            s.pop();
            flag[t] = false;
            sub[num].push_back(t);
        } while (t != x);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            DFS(i);
    printf("%d\n", num);
    for (int i = 1; i <= num; i++) {
        for (int j = 0; j < sub[i].size() - 1; j++)
            printf("%d ", sub[i][j]);
        printf("%d\n", sub[i][sub[i].size() - 1]);
    }
    return 0;
}
\end{lstlisting}
\subsection{Tarjan（点双连通分量）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001, M = 1000001;
int n ,m, u, v, tot, num, idx, Head[N], Next[M << 1], Link[M << 1], dfn[N], low[N];
bool flag[N];
stack<int> s;
vector<int> sub[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
void DFS(int x, int y) {
    s.push(x);
    flag[x] = true;
    low[x] = dfn[x] = ++idx;
    for (int i = Head[x], j; i; i = Next[i]) {
        if ((j = Link[i]) == y)
            continue;
        if (!dfn[j]) {
            DFS(j, x);
            low[x] = min(low[x], low[j]);
        } else if (flag[j])
            low[x] = min(low[x], dfn[j]);
    }
    if (x != y && low[x] >= dfn[y]) {
        int t;
        num++;
        do {
            t = s.top();
            s.pop();
            flag[t] = false;
            sub[num].push_back(t);
        } while (t != y);
        s.push(y);
        flag[y] = true;
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
        AddEdge(v, u);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) {
            DFS(i, i);
            s.pop();
            flag[i] = false;
        }
    printf("%d\n", num);
    for (int i = 1; i <= num; i++) {
        for (int j = 0; j < sub[i].size() - 1; j++)
            printf("%d ", sub[i][j]);
        printf("%d\n", sub[i][sub[i].size() - 1]);
    }
    return 0;
}
\end{lstlisting}
\subsection{Tarjan（边双连通分量）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001, M = 1000001;
int n, m, u, v, tot, num, idx, Head[N], Next[M << 1], Link[M << 1], dfn[M << 1], low[N];
bool flag[N];
stack<int> s;
vector<int> sub[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
void DFS(int x, int y) {
    s.push(x);
    flag[x] = true;
    low[x] = dfn[x] = ++idx;
    for (int i = Head[x], j; i; i = Next[i]) {
        if ((j = Link[i]) == y)
            continue;
        if (!dfn[j]) {
            DFS(j, x);
            low[x] = min(low[x], low[j]);
        } else if (flag[j])
            low[x] = min(low[x], dfn[j]);
    }
    if (low[x] > dfn[y]) {
        int t;
        num++;
        do {
            t = s.top();
            s.pop();
            flag[t] = false;
            sub[num].push_back(t);
        } while (t != x);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
        AddEdge(v, u);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) {
            DFS(i, i);
            num++;
            while (!s.empty()) {
                flag[s.top()] = false;
                sub[num].push_back(s.top());
                s.pop();
            }
        }
    printf("%d\n", num);
    for (int i = 1; i <= num; i++) {
        for (int j = 0; j < sub[i].size() - 1; j++)
            printf("%d ", sub[i][j]);
        printf("%d\n", sub[i][sub[i].size() - 1]);
    }
    return 0;
}
\end{lstlisting}
\subsection{匈牙利}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1001, M = 10001;
int n, m, k, u, v, tot, ans, Head[N], Next[M], Link[M], p[N];
bool flag[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
bool DFS(int x) {
    for (int i = Head[x], j; i; i = Next[i])
        if (!flag[j = Link[i]]) {
            flag[j] = true;
            if (p[j] == 0 || DFS(p[j])) {
                p[j] = x;
                return true;
            }
        }
    return false;
}
int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= k; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
    }
    for (int i = 1; i <= n; i++) {
        memset(flag, false, sizeof(flag));
        if (DFS(i))
            ans++;
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Kuhn-Munkres}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 101;
int n, m, t, ans, a[N][N], lx[N], ly[N], slack[N], p[N];
bool fx[N], fy[N];
bool DFS(int x) {
    fx[x] = true;
    for (int i = 1, t; i <= m; i++)
        if (!fy[i]) {
            t = lx[x] + ly[i] - a[x][i];
            if (!t) {
                fy[i] = true;
                if (p[i] == 0 || DFS(p[i])) {
                    p[i] = x;
                    return true;
                }
            } else
                slack[i] = min(slack[i], lx[x] + ly[i] - a[x][i]);
        }
    return false;
}
bool Find(int x) {
    memset(fx, false, sizeof(fx));
    memset(fy, false, sizeof(fy));
    return DFS(x);
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i++) {
        lx[i] =  INT_MIN;
        for (int j = 1; j <= m; j++)
            lx[i] = max(lx[i], a[i][j]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++)
            slack[j] = INT_MAX;
        while (!Find(i)) {
            t = INT_MAX;
            for (int j = 1; j <= m; j++)
                if (!fy[j])
                    t = min(t, slack[j]);
            for (int j = 1; j <= n; j++)
                if (fx[j])
                    lx[j] -= t;
            for (int j = 1; j <= m; j++)
                if (fy[j])
                    ly[j] += t;
                else
                    slack[j] -= t;
        }
    }
    for (int i = 1; i <= m; i++)
        if (p[i])
            ans += a[p[i]][i];
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Dinic}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1001, M = 10001;
int n, m, S, T, u, v, r, tot, ans;
int Head[N], cur[N], Next[M << 1], Link[M << 1], Rest[M << 1], d[N], From[N], Edge[N];
queue<int> q;
inline void AddEdge(int u, int v, int r) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Rest[tot] = r;
    Head[u] = tot;
}
bool BFS() {
    for (int i = 1; i <= n; i++)
        d[i] = INT_MAX;
    d[S] = 0;
    q.push(S);
    while (!q.empty()) {
        int now = q.front();
        q.pop();
        for (int i = Head[now], j; i; i = Next[i])
            if (Rest[i] > 0 && d[now] + 1 < d[j = Link[i]]) {
                d[j] = d[now] + 1;
                q.push(j);
            }
    }
    return d[T] < INT_MAX;
}
bool DFS(int x) {
    if (x == T) {
        int tmp = INT_MAX;
        for (int i = T; i != S; i = From[i])
            tmp = min(tmp, Rest[Edge[i]]);
        for (int i = T; i != S; i = From[i]) {
            Rest[Edge[i]] -= tmp;
            Rest[Edge[i] ^ 1] += tmp;
        }
        ans += tmp;
        return true;
    }
    for (int &i = cur[x], j; i; i = Next[i])
        if (Rest[i] > 0 && d[x] + 1 == d[j = Link[i]]) {
            From[j] = x;
            Edge[j] = i;
            if (DFS(j))
                return true;
        }
    return false;
}
int main() {
    scanf("%d%d%d%d", &n, &m, &S, &T);
    tot = 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &r);
        AddEdge(u, v, r);
        AddEdge(v, u, 0);
    }
    while (BFS()) {
        memcpy(cur, Head, sizeof(cur));
        while (DFS(S));
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Edmonds-Karp（最小费用最大流）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1001, M = 10001;
int n, m, S, T, u, v, r, c, tmp, tot, sum, ans1, ans2;
int Head[N], Next[M << 1], Link[M << 1], Rest[M << 1], Cost[M << 1], d[N], From[N], Edge[N];
bool flag[N];
queue<int> q;
inline void AddEdge(int u, int v, int r, int c) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Rest[tot] = r;
    Cost[tot] = c;
    Head[u] = tot;
}
bool BFS() {
    for (int i = 1; i <= n; i++)
        d[i] = INT_MAX;
    d[S] = 0;
    q.push(S);
    flag[S] = true;
    while (!q.empty()) {
        int now = q.front();
        q.pop();
        flag[now] = false;
        for (int i = Head[now], j; i; i = Next[i])
            if (Rest[i] > 0 && d[now] + Cost[i] < d[j = Link[i]]) {
                d[j] = d[now] + Cost[i];
                From[j] = now;
                Edge[j] = i;
                if (!flag[j]) {
                    q.push(j);
                    flag[j] = true;
                }
            }
    }
    return d[T] < INT_MAX;
}
int main() {
    scanf("%d%d%d%d", &n, &m, &S, &T);
    tot = 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d%d", &u, &v, &r, &c);
        AddEdge(u, v, r, c);
        AddEdge(v, u, 0, -c);
    }
    while (BFS()) {
        tmp = INT_MAX;
        sum = 0;
        for (int i = T; i != S; i = From[i]) {
            tmp = min(tmp, Rest[Edge[i]]);
            sum += Cost[Edge[i]];
        }
        for (int i = T; i != S; i = From[i]) {
            Rest[Edge[i]] -= tmp;
            Rest[Edge[i] ^ 1] += tmp;
        }
        ans1 += tmp;
        ans2 += tmp * sum;
    }
    printf("%d %d\n", ans1, ans2);
    return 0;
}
\end{lstlisting}
\section{树算法}
\subsection{Tarjan（最近公共祖先）}
\begin{lstlisting}
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
const int N = 1000001, M = 1000001;
int n, m, u, v, tot, Head[N], Next[N << 1], Link[N << 1], a[N], ans[M];
bool flag[N];
vector<pair<int, int> > Q[N];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
int Get(int x) {
    if (a[x] != x)
        a[x] = Get(a[x]);
    return a[x];
}
void DFS(int x) {
    flag[x] = true;
    a[x] = x;
    for (int i = 0; i < Q[x].size(); i++)
        ans[Q[x][i].se] = Get(a[Q[x][i].fi]);
    for (int i = Head[x], j; i; i = Next[i])
        if (!flag[j = Link[i]]) {
            DFS(j);
            a[j] = x;
        }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
        AddEdge(v, u);
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        Q[u].push_back({v, i});
        Q[v].push_back({u, i});
    }
    DFS(1);
    for (int i = 1; i <= m; i++)
        printf("%d\n", ans[i]);
    return 0;
}
\end{lstlisting}
\subsection{树链剖分}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int n, m, u, v, tot, num;
int d[N], f[N], s[N], son[N], top[N], idx[N], key[N], Head[N], Next[N << 1], Link[N << 1];
inline void AddEdge(int u, int v) {
    Next[++tot] = Head[u];
    Link[tot] = v;
    Head[u] = tot;
}
void DFS1(int x) {
    d[x] = d[f[x]] + 1;
    s[x] = 1;
    for (int i = Head[x], j; i; i = Next[i])
        if (!d[j = Link[i]]) {
            f[j] = x;
            DFS1(j);
            s[x] += s[j];
            if (s[j] > s[son[x]])
                son[x] = j;
        }
}
void DFS2(int x) {
    top[x] = x == son[f[x]] ? top[f[x]] : x;
    key[idx[x] = ++num] = x;
    if (son[x])
        DFS2(son[x]);
    for (int i = Head[x], j; i; i = Next[i]) {
        j = Link[i];
        if (f[j] == x && j != son[x])
            DFS2(j);
    }
}
int LCA(int x, int y) {
    int u, v;
    while ((u = top[x]) != (v = top[y]))
        if (d[u] > d[v])
            x = f[u];
        else
            y = f[v];
    if (d[x] > d[y])
        swap(x, y);
    return x;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &u, &v);
        AddEdge(u, v);
        AddEdge(v, u);
    }
    DFS1(1);
    DFS2(1);
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        printf("%d\n", LCA(u, v));
    }
    return 0;
}
\end{lstlisting}
\section{数据结构}
\subsection{并查集}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, a[N], b[N];
int Find(int x) {
    if (a[x] != x)
        a[x] = Find(a[x]);
    return a[x];
}
void Merge(int x, int y) {
    if ((x = Find(x)) == (y = Find(y)))
        return;
    b[x] < b[y] ? a[x] = y : a[y] = x;
    if (b[x] == b[y])
        b[x]++;
}
int main() {
    for (int i = 1; i <= n; i++)
        a[i] = i;
    return 0;
}
\end{lstlisting}
\subsection{字母树}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int pos, son[N][26], num[N];
void Insert(char s[]) {
    int p = 1, t;
    for (int i = 0; s[i]; i++) {
        t = s[i] - 97;
        if (!son[p][t])
            son[p][t] = ++pos;
        p = son[p][t];
    }
    num[p]++;
}
int Find(char s[]) {
    int p = 1, t;
    for (int i = 0; s[i]; i++) {
        t = s[i] - 97;
        if (!son[p][t])
            return 0;
        p = son[p][t];
    }
    return num[p];
}
int main() {
    pos = 1;
    return 0;
}
\end{lstlisting}
\subsection{左偏树}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int pos, l[N], r[N], d[N], key[N];
int Merge(int p, int q) {
    if (!p)
        return q;
    if (!q)
        return p;
    if (key[p] > key[q])
        swap(p, q);
    r[p] = Merge(r[p], q);
    if (d[l[p]] < d[r[p]])
        swap(l[p], r[p]);
    d[p] = d[r[p]] + 1;
    return p;
}
void Push(int &p, int x) {
    key[++pos] = x;
    p = Merge(p, pos);
}
void Pop(int &p) {
    p = Merge(l[p], r[p]);
}
int Top(int p) {
    return key[p];
}
int main() {
    d[0] = -1;
    return 0;
}
\end{lstlisting}
\subsection{树状数组}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int n, sum[N];
void Add(int x, int y) {
    for (; x <= n; x += x & -x)
        sum[x] += y;
}
int Sum(int x) {
    int ans = 0;
    for (; x; x -= x & -x)
        ans += sum[x];
    return ans;
}
int main() {
    return 0;
}
\end{lstlisting}
\subsection{张昆玮线段树}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int n, SIZE, a[N], sum[N << 2];
void Build() {
    for (SIZE = 1; SIZE < n + 2; SIZE <<= 1);
    for (int i = 1; i <= n; i++)
        sum[SIZE + i] = a[i];
    for (int i = SIZE - 1; i; i--)
        sum[i] = sum[i << 1] + sum[(i << 1) + 1];
}
void Add(int x, int y) {
    for (x += SIZE; x; x >>= 1)
        sum[x] += y;
}
int Sum(int x, int y) {
    int ans = 0;
    for (x += SIZE - 1, y += SIZE + 1; x ^ y ^ 1; x >>= 1, y >>= 1) {
        if ((x & 1) == 0)
            ans += sum[x ^ 1];
        if ((y & 1) == 1)
            ans += sum[y ^ 1];
    }
    return ans;
}
int main() {
    return 0;
}
\end{lstlisting}
\subsection{线段树}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int pos, a[N], l[N << 1], r[N << 1], ll[N << 1], rr[N << 1], sum[N << 1], lab[N << 1];
inline void Label(int p, int x) {
    sum[p] += (rr[p] - ll[p] + 1) * x;
    lab[p] += x;
}
inline void Down(int p) {
    if (ll[p] < rr[p]) {
        Label(l[p], lab[p]);
        Label(r[p], lab[p]);
    }
    lab[p] = 0;
}
inline void Up(int p) {
    sum[p] = sum[l[p]] + sum[r[p]];
}
void Build(int p, int x, int y) {
    ll[p] = x;
    rr[p] = y;
    if (x == y) {
        sum[p] = a[x];
        return;
    }
    int z = x + y >> 1;
    Build(l[p] = ++pos, x, z);
    Build(r[p] = ++pos, z + 1, y);
    Up(p);
}
void Add(int p, int x, int y, int z) {
    Down(p);
    if (ll[p] == x && rr[p] == y) {
        Label(p, z);
        return;
    }
    if (y < ll[r[p]])
        Add(l[p], x, y, z);
    else if (x > rr[l[p]])
        Add(r[p], x, y, z);
    else {
        Add(l[p], x, rr[l[p]], z);
        Add(r[p], ll[r[p]], y, z);
    }
    Up(p);
}
int Sum(int p, int x, int y) {
    Down(p);
    if (ll[p] == x && rr[p] == y)
        return sum[p];
    if (y < ll[r[p]])
        return Sum(l[p], x, y);
    else if (x > rr[l[p]])
        return Sum(r[p], x, y);
    else
        return Sum(l[p], x, rr[l[p]]) + Sum(r[p], ll[r[p]], y);
}
int main() {
    pos = 1;
    return 0;
}
\end{lstlisting}
\subsection{伸展树（区间）}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int root, pos, l[N], r[N], f[N], s[N], key[N], lab[N], sum[N];
bool flag[N];
inline void Down(int p) {
    if (l[p]) {
        key[l[p]] += lab[p];
        lab[l[p]] += lab[p];
        sum[l[p]] += s[l[p]] * lab[p];
        if (flag[p]) {
            flag[l[p]] = !flag[l[p]];
            swap(l[l[p]], r[l[p]]);
        }
    }
    if (r[p]) {
        key[r[p]] += lab[p];
        lab[r[p]] += lab[p];
        sum[r[p]] += s[r[p]] * lab[p];
        if (flag[p]) {
            flag[r[p]] = !flag[r[p]];
            swap(l[r[p]], r[r[p]]);
        }
    }
    lab[p] = 0;
    flag[p] = false;
}
inline void Up(int p) {
    s[p] = s[l[p]] + s[r[p]] + 1;
    sum[p] = sum[l[p]] + sum[r[p]] + key[p];
}
inline void L(int p) {
    int t = f[p];
    if (r[t] = l[p])
        f[l[p]] = t;
    if (f[p] = f[t])
        t == l[f[t]] ? l[f[t]] = p : r[f[t]] = p;
    f[t] = p;
    l[p] = t;
}
inline void R(int p) {
    int t = f[p];
    if (l[t] = r[p])
        f[r[p]] = t;
    if (f[p] = f[t])
        t == l[f[t]] ? l[f[t]] = p : r[f[t]] = p;
    f[t] = p;
    r[p] = t;
}
void Splay(int p, int T) {
    for (int q, t; (q = f[p]) != T; )
        if (f[q] == T) {
            p == l[q] ? R(p) : L(p);
            Up(q), Up(p);
        } else {
            t = f[q];
            if (p == l[q])
                q == l[t] ? (R(q), R(p)) : (R(p), L(p));
            else
                q == r[t] ? (L(q), L(p)) : (L(p), R(p));
            Up(t), Up(q), Up(p);
        }
    if (!T)
        root = p;
}
int Select(int x) {
    int p = root, t = s[l[root]];
    Down(p);
    while (x != t + 1) {
        if (x < t + 1)
            t -= s[r[p = l[p]]] + 1;
        else
            t += s[l[p = r[p]]] + 1;
        Down(p);
    }
    return p;
}
void Insert(int x, int y) {
    int p = Select(x + 1);
    Splay(p, 0);
    Down(p);
    for (p = r[p]; l[p]; p = l[p])
        Down(p);
    Down(p);
    l[p] = ++pos;
    f[pos] = p;
    sum[pos] = key[pos] = y;
    Splay(pos, 0);
}
void Delete(int x) {
    int p = Select(x + 1);
    Splay(p, 0);
    Down(p);
    for (p = l[p]; r[p]; p = r[p])
        Down(p);
    Down(p);
    f[r[root]] = p;
    r[p] = r[root];
    f[l[root]] = 0;
    Splay(p, 0);
}
void Add(int x, int y, int z) {
    Splay(Select(x), 0);
    Splay(Select(y + 2), root);
    key[l[r[root]]] += z;
    lab[l[r[root]]] += z;
    sum[l[r[root]]] += s[l[r[root]]] * z;
    Up(r[root]), Up(root);
}
void Reverse(int x, int y) {
    Splay(Select(x), 0);
    Splay(Select(y + 2), root);
    flag[l[r[root]]] = !flag[l[r[root]]];
    swap(l[l[r[root]]], r[l[r[root]]]);
    Up(r[root]), Up(root);
}
int Sum(int x, int y) {
    Splay(Select(x), 0);
    Splay(Select(y + 2), root);
    return sum[l[r[root]]];
}
int main() {
    root = 1;
    pos = 2;
    r[1] = s[1] = 2;
    f[2] = s[2] = 1;
    return 0;
}
\end{lstlisting}
\subsection{红黑树}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int root, pos, l[N], r[N], s[N], key[N];
bool clr[N];
inline void L(int &p) {
    int t = r[p];
    r[p] = l[t];
    l[t] = p;
    s[t] = s[p];
    s[p] = s[l[p]] + s[r[p]] + 1;
    p = t;
}
inline void R(int &p) {
    int t = l[p];
    l[p] = r[t];
    r[t] = p;
    s[t] = s[p];
    s[p] = s[l[p]] + s[r[p]] + 1;
    p = t;
}
void Fix(int &p) {
    if (clr[r[p]]) {
        L(p);
        swap(clr[p], clr[l[p]]);
    }
    if (clr[l[p]] && clr[l[l[p]]]) {
        R(p);
        clr[l[p]] = false;
    }
    if (p == root)
        clr[p] = false;
}
void Insert(int &p, int x) {
    if (p) {
        s[p]++;
        Insert(x < key[p] ? l[p] : r[p], x);
        Fix(p);
    } else {
        p = ++pos;
        key[p] = x;
        s[p] = 1;
        clr[p] = true;
    }
}
int Delete(int &p, int x) {
    int ans;
    s[p]--;
    if (x == key[p] || x < key[p] && !l[p] || x > key[p] && !r[p]) {
        ans = key[p];
        l[p] ? key[p] = Delete(l[p], x + 1) : p = r[p];
    } else
        ans = Delete(x < key[p] ? l[p] : r[p], x);
    return ans;
}
int Rank(int x) {
    int p = root, t = s[l[root]], ans;
    while (p)
        if (x <= key[p]) {
            ans = t;
            p = l[p];
            t -= s[r[p]] + 1;
        } else {
            p = r[p];
            t += s[l[p]] + 1;
        }
    return ans + 1;
}
int Select(int x) {
    int p = root, t = s[l[root]];
    while (x != t + 1)
        if (x < t + 1) {
            p = l[p];
            t -= s[r[p]] + 1;
        } else {
            p = r[p];
            t += s[l[p]] + 1;
        }
    return key[p];
}
int Pred(int x) {
    int p = root, t;
    while (p)
        if (x > key[p]) {
            t = p;
            p = r[p];
        } else
            p = l[p];
    return key[t];
}
int Succ(int x) {
    int p = root, t;
    while (p)
        if (x < key[p]) {
            t = p;
            p = l[p];
        } else
            p = r[p];
    return key[t];
}
int main() {
    return 0;
}
\end{lstlisting}
\subsection{后缀数组}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
int n, a[N], b[N], sum[N], tmp[N], id[N], rk[N], g[N], h[N];
char s[N + 10];
void Sort(int a[], int m) {
    memset(sum, 0, sizeof(sum));
    for (int i = 1; i <= n; i++)
        sum[a[i]]++;
    for (int i = 1; i <= m; i++)
        sum[i] += sum[i - 1];
    for (int i = n; i; i--)
        tmp[id[i]] = sum[a[id[i]]]--;
    for (int i = 1; i <= n; i++)
        id[tmp[i]] = i;
}
void Build() {
    n = strlen(s + 1);
    for (int i = 1; i <= n; i++)
        a[id[i] = i] = s[i] - 96;
    Sort(a, 26);
    for (int i = 1, t = 0; i <= n; i++)
        rk[id[i]] = a[id[i]] == a[id[i - 1]] ? t : ++t;
    for (int i = 1; i <= n; i <<= 1) {
        for (int j = 1; j <= n; j++) {
            a[j] = rk[j];
            b[j] = rk[min(i + j, n + 1)];
        }
        Sort(b, n);
        Sort(a, n);
        for (int j = 1, t = 0; j <= n; j++)
            rk[id[j]] = a[id[j]] == a[id[j - 1]] && b[id[j]] == b[id[j - 1]] ? t : ++t;
    }
    for (int i = 1; i <= n; i++) {
        for (g[i] = max(g[i - 1] - 1, 0); s[i + g[i]] == s[id[rk[i] - 1] + g[i]]; g[i]++);
        h[rk[i]] = g[i];
    }
}
int main() {
    return 0;
}
\end{lstlisting}
\subsection{后缀自动机}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, pos, last, son[N << 1][26], par[N << 1], val[N << 1], sz[N << 1];
int sum[N], id[N << 1], rk[N << 1];
char s[N + 10];
void Insert(int x) {
    int p = last, np = ++pos;
    val[np] = val[p] + 1;
    sz[np] = 1;
    for (; p > 0 && !son[p][x]; p = par[p])
        son[p][x] = np;
    if (!p)
        par[np] = 1;
    else {
        int q = son[p][x], nq;
        if (val[q] == val[p] + 1)
            par[np] = q;
        else {
            nq = ++pos;
            memcpy(son[nq], son[q], sizeof(son[q]));
            par[nq] = par[q];
            val[nq] = val[p] + 1;
            par[q] = par[np] = nq;
            for (; p > 0 && son[p][x] == q; p = par[p])
                son[p][x] = nq;
        }
    }
    last = np;
}
void Build() {
    n = strlen(s + 1);
    last = pos = 1;
    for (int i = 1; i <= n; i++)
        Insert(s[i] - 97);
    for (int i = 1; i <= pos; i++)
        sum[val[i]]++;
    for (int i = 1; i <= n; i++)
        sum[i] += sum[i - 1];
    for (int i = pos; i; i--)
        rk[i] = sum[val[i]]--;
    for (int i = 1; i <= pos; i++)
        id[rk[i]] = i;
    for (int i = pos; i; i--)
        sz[par[id[i]]] += sz[id[i]];
}
int main() {
    return 0;
}
\end{lstlisting}
\section{数学}
\subsection{快速幂}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
int a, b, ans;
int main() {
    scanf("%d%d", &a, &b);
    ans = 1;
    while (b) {
        if (b & 1)
            ans = ans * a;
        a = a * a;
        b >>= 1;
    }
    printf("%d\n", ans);
    return 0;
}
\end{lstlisting}
\subsection{Euclid}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
int a, b;
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
int main() {
    scanf("%d%d", &a, &b);
    printf("%d\n", gcd(a, b));
    return 0;
}
\end{lstlisting}
\subsection{扩展Euclid}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
int a, b, x, y, t;
int gcd(int a, int b, int &x, int &y) {
    if (b) {
        int t, xt, yt;
        t = gcd(b, a % b, xt, yt);
        x = yt;
        y = xt - a / b * yt;
        return t;
    } else {
        x = 1;
        y = 0;
        return a;
    }
}
int main() {
    scanf("%d%d", &a, &b);
    t = gcd(a, b, x, y);
    printf("%d %d %d\n", x, y, t);
    return 0;
}
\end{lstlisting}
\subsection{Miller-Rabin测试}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
ll Mul(ll a, ll b, ll MOD) {
    ll ans = 0;
    while (b) {
        if (b & 1)
            ans = (ans + a) % MOD;
        a = (a << 1) % MOD;
        b >>= 1;
    }
    return ans;
}
ll Pow(ll a, ll b, ll MOD) {
    ll ans = 1;
    while (b) {
        if (b & 1)
            ans = Mul(ans, a, MOD);
        a = Mul(a, a, MOD);
        b >>= 1;
    }
    return ans;
}
bool Judge(ll p) {
    if (p < 2)
        return false;
    int num = 0;
    ll t = p - 1, t1, t2;
    for (; !(t & 1); t >>= 1)
        num++;
    for (int i = 0; i < 5; i++) {
        t1 = Pow(rand() % (p - 1) + 1, t, p);
        for (int j = 0; t1 != 1 && j < num; j++) {
            t2 = Mul(t1, t1, p);
            if (t1 != 1 && t1 != p - 1 && t2 == 1)
                return false;
            t1 = t2;
        }
        if (t1 != 1)
            return false;
    }
    return true;
}
int main() {
    srand(time(NULL));
    scanf("%lld", &n);
    puts(Judge(n) ? "YES" : "NO");
    return 0;
}
\end{lstlisting}
\subsection{Euler筛}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 1000001;
int n, num, p[N], fai[N], miu[N];
bool flag[N];
int main() {
    scanf("%d", &n);
    fai[1] = miu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!flag[i]) {
            p[++num] = i;
            fai[i] = i - 1;
            miu[i] = -1;
        }
        for (int j = 1; j <= num; j++) {
            if (i * p[j] > n)
                break;
            flag[i * p[j]] = true;
            if (i % p[j] == 0) {
                fai[i * p[j]] = fai[i] * p[j];
                miu[i * p[j]] = 0;
                break;
            } else {
                fai[i * p[j]] = fai[i] * (p[j] - 1);
                miu[i * p[j]] = -miu[i];
            }
        }
    }
    printf("%d\n", num);
    for (int i = 1; i < num; i++)
        printf("%d ", p[i]);
    printf("%d\n", p[num]);
    for (int i = 1; i < n; i++)
        printf("%d ", fai[i]);
    printf("%d\n", fai[n]);
    for (int i = 1; i < n; i++)
        printf("%d ", miu[i]);
    printf("%d\n", miu[n]);
    return 0;
}
\end{lstlisting}
\subsection{Gauss消元}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 101, M = 101;
const double EPS = 1e-5;
int n, m, tmp;
double a[M][N + 1], t[M][N + 1], temp[N + 1];
bool flag;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n + 1; j++)
            scanf("%lf", &t[i][j]);
    for (int i = 1; i <= n; i++) {
        tmp = 0;
        for (int j = 1; j <= m; j++) {
            flag = false;
            for (int k = 1; !flag && k <= n; k++)
                if (fabs(t[j][k]) > EPS)
                    flag = true;
            if (flag)
                memcpy(a[++tmp], t[j], sizeof(t[j]));
            else if (fabs(t[j][n + 1]) > EPS) {
                puts("No Solution");
                return 0;
            }
        }
        if ((m = tmp) < n) {
            puts("Infinite Solutions");
            return 0;
        }
        flag = false;
        for (int j = i; !flag && j <= m; j++)
            if (fabs(a[j][i]) > EPS) {
                memcpy(temp, a[i], sizeof(temp));
                memcpy(a[i], a[j], sizeof(temp));
                memcpy(a[j], temp, sizeof(temp));
                flag = true;
            }
        if (!flag) {
            puts("Infinite Solutions");
            return 0;
        }
        for (int j = i + 1; j <= n + 1; j++)
            a[i][j] /= a[i][i];
        a[i][i] = 1;
        for (int j = i + 1; j <= m; j++) {
            for (int k = i + 1; k <= n + 1; k++)
                a[j][k] -= a[i][k] * a[j][i];
            a[j][i] = 0;
        }
        memcpy(t, a, sizeof(a));
    }
    for (int i = n - 1; i; i--)
        for (int j = i + 1; j <= n; j++)
            a[i][n + 1] -= a[i][j] * a[j][n + 1];
    for (int i = 1; i < n; i++)
        printf("%f ", a[i][n + 1]);
    printf("%f\n", a[n][n + 1]);
    return 0;
}
\end{lstlisting}
\subsection{快速Fourier变换}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 100001;
const double PI = acos(-1);
int n, m, LENG, SIZE;
double t;
complex<double> a[N << 2], b[N << 2], c[N << 2];
complex<double> ya[N << 2], yb[N << 2], yc[N << 2], yt[N << 2];
void DFT(complex<double> a[], complex<double> y[], bool flag) {
    for (int i = 0; i < SIZE; i++) {
        int t = 0;
        for (int j = 0; j < LENG; j++)
            t += (i >> j & 1) << LENG - j - 1;
        y[i] = a[t];
    }
    for (int t = 1; t < SIZE; t <<= 1) {
        double tmp = (flag ? -1 : 1) * PI / t;
        for (int i = 0; i < SIZE; i += t << 1)
            for (int j = 0; j < t; j++) {
                yt[i + j] = y[i + j] + polar(1.0, tmp * j) * y[i + t + j];
                yt[i + t + j] = y[i + j] + polar(1.0, tmp * (t + j)) * y[i + t + j];
            }
        memcpy(y, yt, sizeof(yt));
    }
    if (flag)
        for (int i = 0; i < SIZE; i++)
            y[i] /= SIZE;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%lf", &t);
        a[i] = {t, 0};
    }
    for (int i = 0; i < m; i++) {
        scanf("%lf", &t);
        b[i] = {t, 0};
    }
    for (LENG = 0, SIZE = 1; SIZE < n + m - 1; LENG++, SIZE <<= 1);
    DFT(a, ya, false);
    DFT(b, yb, false);
    for (int i = 0; i < SIZE; i++)
        yc[i] = ya[i] * yb[i];
    DFT(yc, c, true);
    for (int i = 0; i < n + m - 2; i++)
        printf("%f ", c[i].real());
    printf("%f\n", c[n + m - 2].real());
    return 0;
}
\end{lstlisting}
\section{计算几何}
\subsection{线段相交}
\begin{lstlisting}
#include <bits/stdc++.h>
#define x first
#define y second
#define x1 first.first
#define y1 first.second
#define x2 second.first
#define y2 second.second
using namespace std;
typedef pair<double, double> Point;
typedef pair<Point, Point> Segment;
Segment a, b;
inline double Cross(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
inline bool Judge(Segment a, Segment b) {
    if (max(a.x1, a.x2) < min(b.x1, b.x2) || max(b.x1, b.x2) < min(a.x1, a.x2))
        return false;
    if (max(a.y1, a.y2) < min(b.y1, b.y2) || max(b.y1, b.y2) < min(a.y1, a.y2))
        return false;
    return Cross(a.x, a.y, b.x) * Cross(a.x, a.y, b.y) <= 0 &&
           Cross(b.x, b.y, a.x) * Cross(b.x, b.y, a.y) <= 0;
}
int main() {
    scanf("%lf%lf%lf%lf%lf%lf%lf%lf", &a.x1, &a.y1, &a.x2, &a.y2, &b.x1, &b.y1, &b.x2, &b.y2);
    puts(Judge(a, b) ? "Yes" : "No");
    return 0;
}

\end{lstlisting}
\subsection{多边形面积}
\begin{lstlisting}
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<double, double> Point;
const int N = 1000001;
int n;
double ans;
Point p[N];
inline double Cross(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf%lf", &p[i].x, &p[i].y);
    for (int i = 3; i <= n; i++)
        ans += Cross(p[1], p[i - 1], p[i]);
    printf("%f\n", ans / 2);
    return 0;
}
\end{lstlisting}
\subsection{Graham扫描}
\begin{lstlisting}
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<double, double> Point;
const int N = 100001;
int n, top;
Point p[N], s[N];
inline double Sqr(double x) {
    return x * x;
}
inline double Dist(Point a, Point b) {
    return sqrt(Sqr(a.x - b.x) + Sqr(a.y - b.y));
}
inline double Cross(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
inline bool cmp(Point a, Point b) {
    return Cross(p[0], a, b) > 0 || Cross(p[0], a, b) == 0 && Dist(p[0], a) < Dist(p[0], b);
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%lf%lf", &p[i].x, &p[i].y);
        if (p[i].y < p[0].y || p[i].y == p[0].y && p[i].x < p[0].x)
            swap(p[0], p[i]);
    }
    sort(p + 1, p + n, cmp);
    s[top = 1] = p[0];
    for (int i = 1; i < n; i++) {
        for (; top > 1 && Cross(s[top - 1], s[top], p[i]) < 0; top--);
        s[++top] = p[i];
    }
    for (; top > 2 && Cross(s[top - 1], s[top], s[1]) < 0; top--);
    printf("%d\n", top);
    for (int i = 1; i <= top; i++)
        printf("%f %f\n", s[i].x, s[i].y);
    return 0;
}
\end{lstlisting}
\subsection{最小圆覆盖}
\begin{lstlisting}
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<double, double> Point;
const int N = 1000001;
const double EPS = 1e-5;
int n;
double r;
Point O, p[N];
inline double Sqr(double x) {
    return x * x;
}
inline double Dist(Point a, Point b) {
    return sqrt(Sqr(a.x - b.x) + Sqr(a.y - b.y));
}
inline Point Calc(Point a, Point b, Point c) {
    if (fabs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) < EPS)
        if (Dist(a, c) > Dist(b, c))
            return {(a.x + c.x) / 2, (a.y + c.y) / 2};
        else
            return {(b.x + c.x) / 2, (b.y + c.y) / 2};
    double k1, k2, b1, b2;
    k1 = (a.x - c.x) / (c.y - a.y);
    b1 = (a.y + c.y) / 2 - k1 * (a.x + c.x) / 2;
    k2 = (b.x - c.x) / (c.y - b.y);
    b2 = (b.y + c.y) / 2 - k2 * (b.x + c.x) / 2;
    return {(b2 - b1) / (k1 - k2), (k1 * b2 - k2 * b1) / (k1 - k2)};
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf%lf", &p[i].x, &p[i].y);
    random_shuffle(p + 1, p + n + 1);
    O = p[1];
    r = 0;
    for (int i = 2; i <= n; i++)
        if (Dist(O, p[i]) > r) {
            O = p[i];
            r = 0;
            for (int j = 1; j < i; j++)
                if (Dist(O, p[j]) > r) {
                    O = {(p[i].x + p[j].x) / 2, (p[i].y + p[j].y) / 2};
                    r = Dist(O, p[j]);
                    for (int k = 1; k < j; k++)
                        if (Dist(O, p[k]) > r) {
                            O = Calc(p[i], p[j], p[k]);
                            r = Dist(O, p[k]);
                        }
                }
        }
    printf("%f %f\n%f\n", O.x, O.y, r);
    return 0;
}
\end{lstlisting}
\section{其他}
\lstset{language = Java, basicstyle = \footnotesize\consolas, numbers = left, numberstyle = \footnotesize\consolas, frame = single, keywordstyle = \color{blue}, stringstyle = \color{red}, commentstyle = \color{gray}}
\subsection{Java BigInteger}
\begin{lstlisting}
import java.lang.Math;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.Scanner;
public class Main {
    public static void main(String args[]) {
        Scanner read = new Scanner(System.in);
        BigInteger a = read.nextBigInteger();
        BigInteger b = read.nextBigInteger();
        System.out.println(a.add(b));
        System.out.println(a.subtract(b));
        System.out.println(a.multiply(b));
        System.out.println(a.divide(b));
    }
}
\end{lstlisting}
\subsection{Java BigDecimal}
\begin{lstlisting}
import java.lang.Math;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.Scanner;
public class Main {
    public static void main(String args[]) {
        Scanner read = new Scanner(System.in);
        BigDecimal a = read.nextBigDecimal();
        BigDecimal b = read.nextBigDecimal();
        System.out.println(a.add(b));
        System.out.println(a.subtract(b));
        System.out.println(a.multiply(b));
        System.out.println(a.divide(b, 5, BigDecimal.ROUND_DOWN));
        System.out.println(a.divide(b, 5, BigDecimal.ROUND_UP));
        System.out.println(a.divide(b, 5, BigDecimal.ROUND_HALF_DOWN));
        System.out.println(a.divide(b, 5, BigDecimal.ROUND_HALF_UP));
    }
}
\end{lstlisting}
\lstset{language = lisp, basicstyle = \footnotesize\consolas, numbers = left, numberstyle = \footnotesize\consolas, frame = single, keywordstyle = \color{blue}, stringstyle = \color{red}, commentstyle = \color{gray}}
\subsection{Emacs配置}
\begin{lstlisting}
;;括号补全
(electric-pair-mode t)
;;括号匹配
(show-paren-mode t)
;;显示行号
(global-linum-mode t)
;;一键打开终端
(global-set-key (kbd "<f10>") 'shell)
;;一键编译
(defun compile-file ()
  (interactive)
  (compile (format "g++ -o %s %s -g -Wall" (file-name-sans-extension (buffer-name)) 
                                           (buffer-name))))
(global-set-key (kbd "<f9>") 'compile-file)
;;一键调试
(global-set-key (kbd "<f7>") 'gud-gdb)
\end{lstlisting}
\end{document}
